<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Experiment Of Informations Varized in Text</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: 
                linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px),
                linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px),
                linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            background-size: 20px 20px, 20px 20px, 100% 100%;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .loading-screen.fade-out {
            opacity: 0;
            transform: scale(0.95);
        }

        .loading-content {
            text-align: center;
        }

        .loading-text {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 30px;
            opacity: 0;
            transform: translateY(20px);
            animation: slideUp 0.5s ease forwards;
        }

        @keyframes slideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .spinner {
            display: none;
        }

        .loading-footer {
            position: absolute;
            bottom: 30px;
            font-size: 14px;
            color: #999;
            font-style: italic;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .main-screen {
            display: none;
            text-align: center;
            padding: 40px 20px;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }

        .main-screen.show {
            opacity: 1;
            transform: translateY(0);
        }

        h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #222;
            text-shadow: 4px 4px 0px #e0e0e0;
        }

        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 40px;
        }

        .mode-selection {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin: 50px 0;
            flex-wrap: wrap;
        }

        .mode-card {
            background: white;
            border: 4px solid #333;
            border-radius: 20px;
            padding: 40px 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 8px 8px 0px #333;
            position: relative;
            overflow: hidden;
        }

        .mode-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0,0,0,0.05) 0%, transparent 70%);
            transform: scale(0);
            transition: transform 0.6s ease;
        }

        .mode-card:hover::before {
            transform: scale(1);
        }

        .mode-card:hover {
            transform: translate(-8px, -8px) rotate(-2deg);
            box-shadow: 16px 16px 0px #333;
        }

        .mode-card:active {
            transform: translate(4px, 4px) rotate(0deg) scale(0.98);
            box-shadow: 2px 2px 0px #333;
        }

        .mode-card h2 {
            font-size: 32px;
            margin-bottom: 15px;
            color: #222;
        }

        .mode-card p {
            font-size: 16px;
            color: #666;
        }

        .game-screen {
            display: none;
            text-align: center;
            padding: 40px 20px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .game-screen.show {
            opacity: 1;
        }

        .word-display {
            font-size: 64px;
            font-weight: bold;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 50px 0;
            background: white;
            border: 4px solid #333;
            border-radius: 20px;
            box-shadow: 8px 8px 0px #333;
            padding: 20px;
            position: relative;
            overflow: hidden;
            animation: popIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes popIn {
            0% {
                transform: scale(0.5) rotate(-5deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) rotate(2deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .word-display::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border: 2px dashed rgba(0,0,0,0.1);
            border-radius: 20px;
            animation: rotateBorder 20s linear infinite;
        }

        @keyframes rotateBorder {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .captcha-text {
            position: relative;
            display: inline-block;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            filter: contrast(150%);
        }

        .captcha-letter {
            display: inline-block;
            position: relative;
            margin: 0 3px;
        }

        .captcha-noise {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0,0,0,0.03) 1px, rgba(0,0,0,0.03) 2px),
                repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(0,0,0,0.03) 1px, rgba(0,0,0,0.03) 2px),
                repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(0,0,0,0.02) 2px, rgba(0,0,0,0.02) 4px),
                repeating-linear-gradient(-45deg, transparent, transparent 2px, rgba(0,0,0,0.02) 2px, rgba(0,0,0,0.02) 4px);
            pointer-events: none;
        }

        .captcha-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            background-image: radial-gradient(circle at 20% 50%, transparent 20%, rgba(0,0,0,0.015) 21%),
                              radial-gradient(circle at 60% 30%, transparent 20%, rgba(0,0,0,0.015) 21%),
                              radial-gradient(circle at 80% 70%, transparent 20%, rgba(0,0,0,0.015) 21%);
            background-size: 15px 15px, 20px 20px, 18px 18px;
        }

        .captcha-line {
            position: absolute;
            width: 120%;
            height: 2px;
            background: rgba(0,0,0,0.35);
            left: -10%;
        }

        .captcha-wave {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 3px,
                rgba(255,255,255,0.1) 3px,
                rgba(255,255,255,0.1) 6px
            );
            pointer-events: none;
        }

        .progress-bar {
            width: 100%;
            height: 40px;
            background: white;
            border: 4px solid #333;
            border-radius: 25px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
            box-shadow: inset 0 4px 8px rgba(0,0,0,0.1), 4px 4px 0px #333;
        }

        .progress-fill {
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                #333,
                #333 10px,
                #555 10px,
                #555 20px
            );
            transition: width 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border-radius: 20px;
            position: relative;
            animation: progressShine 2s linear infinite;
        }

        @keyframes progressShine {
            0% {
                background-position: 0 0;
            }
            100% {
                background-position: 40px 0;
            }
        }

        .recall-screen {
            display: none;
            padding: 40px 20px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .recall-screen.show {
            opacity: 1;
        }

        .recall-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .recall-input-wrapper {
            position: relative;
        }

        .recall-input {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 3px solid #333;
            border-radius: 10px;
            background: white;
            box-shadow: 4px 4px 0px #333;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .recall-input:focus {
            outline: none;
            transform: translate(-4px, -4px) scale(1.02);
            box-shadow: 8px 8px 0px #333;
            border-color: #000;
        }

        .recall-input:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0px #333;
        }

        .recall-label {
            position: absolute;
            top: -10px;
            left: 10px;
            background: white;
            padding: 0 5px;
            font-size: 14px;
            font-weight: bold;
            color: #666;
        }

        .results-screen {
            display: none;
            padding: 40px 20px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .results-screen.show {
            opacity: 1;
        }

        .results-card {
            background: white;
            border: 4px solid #333;
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 8px 8px 0px #333;
            animation: slideInUp 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) backwards;
        }

        .results-card:nth-child(1) {
            animation-delay: 0.1s;
        }

        .results-card:nth-child(2) {
            animation-delay: 0.2s;
        }

        .results-card:nth-child(3) {
            animation-delay: 0.3s;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(50px) rotate(-5deg);
            }
            to {
                opacity: 1;
                transform: translateY(0) rotate(0deg);
            }
        }

        .accuracy-display {
            font-size: 72px;
            font-weight: bold;
            color: #222;
            margin: 20px 0;
            animation: countUp 1.5s ease-out, pulse 2s ease-in-out infinite;
            display: inline-block;
        }

        @keyframes countUp {
            from {
                transform: scale(0) rotate(-180deg);
                opacity: 0;
            }
            to {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin: 20px 0;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 2px solid #333;
        }

        th {
            background: #f5f5f5;
            font-weight: bold;
        }

        .correct {
            color: #2d7a2d;
            font-weight: bold;
        }

        .incorrect {
            color: #c53030;
            font-weight: bold;
        }

        button {
            background: white;
            border: 3px solid #333;
            border-radius: 12px;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 6px 6px 0px #333;
            transition: all 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            margin: 10px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: left 0.5s ease;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translate(-4px, -4px) scale(1.05);
            box-shadow: 10px 10px 0px #333;
        }

        button:active {
            transform: translate(3px, 3px) scale(0.95);
            box-shadow: 2px 2px 0px #333;
        }

        .research-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 10px 20px;
            border: 3px solid #333;
            border-radius: 25px;
            box-shadow: 4px 4px 0px #333;
            font-size: 14px;
            font-weight: bold;
        }

        .toggle-switch {
            width: 50px;
            height: 26px;
            background: #e0e0e0;
            border: 2px solid #333;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #333;
        }

        .toggle-slider {
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid #333;
            border-radius: 50%;
            position: absolute;
            top: 1px;
            left: 1px;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        .trial-counter {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 10px 20px;
            border: 3px solid #333;
            border-radius: 15px;
            box-shadow: 4px 4px 0px #333;
            font-weight: bold;
        }

        canvas {
            max-width: 100%;
            border: 3px solid #333;
            border-radius: 10px;
            background: white;
            margin: 20px 0;
        }

        .decorative-shapes {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: -1;
        }

        .shape {
            position: absolute;
            border: 3px solid rgba(0,0,0,0.1);
            animation: float 20s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(30px, -30px) rotate(90deg);
            }
            50% {
                transform: translate(-20px, 20px) rotate(180deg);
            }
            75% {
                transform: translate(40px, 10px) rotate(270deg);
            }
        }

        .shape:nth-child(even) {
            animation-direction: reverse;
            animation-duration: 25s;
        }

        .circle {
            border-radius: 50%;
        }

        .square {
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="decorative-shapes" id="shapes"></div>

    <div class="loading-screen" id="loadingScreen">
        <div class="loading-content">
            <div class="loading-text" id="loadingText">Loading experiment!</div>
            <div style="width: 400px; margin: 30px auto;">
                <div style="width: 100%; height: 40px; background: white; border: 4px solid #333; border-radius: 25px; overflow: hidden; box-shadow: inset 0 4px 8px rgba(0,0,0,0.1), 4px 4px 0px #333;">
                    <div id="loadingBar" style="height: 100%; width: 0%; background: repeating-linear-gradient(45deg, #333, #333 10px, #555 10px, #555 20px); transition: width 0.3s ease; border-radius: 20px;"></div>
                </div>
            </div>
        </div>
        <div class="loading-footer">Investigating visual memory retention</div>
    </div>

    <div class="research-toggle" id="researchToggle">
        <span>Research Mode</span>
        <div class="toggle-switch" id="toggleSwitch">
            <div class="toggle-slider"></div>
        </div>
    </div>

    <div class="trial-counter" id="trialCounter" style="display: none;">
        Control: <span id="controlCount">0</span>/10 | Experimental: <span id="expCount">0</span>/10
    </div>

    <div class="container">
        <div class="main-screen" id="mainScreen">
            <h1>A Experiment Of Informations Varized in Text</h1>
            <p class="subtitle">Investigating how visual overlays affect memory retention</p>

            <div class="mode-selection">
                <div class="mode-card" onclick="startGame('control')">
                    <h2>Control</h2>
                    <p>Standard text display</p>
                </div>
                <div class="mode-card" onclick="startGame('experimental')">
                    <h2>Experimental</h2>
                    <p>Distorted CAPTCHA-style text</p>
                </div>
            </div>
        </div>

        <div class="game-screen" id="gameScreen">
            <h2>Memorize these words!</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="word-display" id="wordDisplay"></div>
            <p id="wordCounter">Word 0 of 15</p>
        </div>

        <div class="recall-screen" id="recallScreen">
            <h2>Type the words you remember (in order)</h2>
            <div class="recall-grid" id="recallGrid"></div>
            <button onclick="submitRecall()">Submit Answers</button>
        </div>

        <div class="results-screen" id="resultsScreen">
            <h2>Results</h2>
            <div class="results-card">
                <h3>Overall Accuracy</h3>
                <div class="accuracy-display" id="accuracyDisplay">0%</div>
                <p><strong>Mode:</strong> <span id="modeDisplay"></span></p>
            </div>

            <div class="results-card">
                <h3>Performance Analysis</h3>
                <canvas id="scatterPlot" width="800" height="400"></canvas>
                <div id="analysisText" style="margin-top: 20px; padding: 20px; background: #f5f5f5; border-radius: 10px; text-align: left;">
                    <p style="color: #666; font-style: italic;">Analyzing results with AI...</p>
                </div>
            </div>

            <div class="results-card">
                <h3>Word-by-Word Breakdown</h3>
                <table id="resultsTable"></table>
            </div>

            <button onclick="returnToMain()">Try Another Mode</button>
            <button onclick="exportResults()">Export Data</button>
        </div>
    </div>

    <script>

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        let currentMode = '';
        let shownWords = [];
        let currentWordIndex = 0;
        let researchMode = false;
        let gameHistory = {
            control: [],
            experimental: []
        };

        const wordPool = [
            'about', 'after', 'again', 'below', 'could', 'every', 'first', 'found', 'great', 'group',
            'hand', 'help', 'high', 'house', 'large', 'last', 'later', 'learn', 'leave', 'light',
            'live', 'long', 'made', 'make', 'many', 'might', 'more', 'most', 'move', 'much',
            'must', 'name', 'never', 'next', 'night', 'only', 'other', 'over', 'part', 'place',
            'point', 'right', 'same', 'seem', 'show', 'small', 'sound', 'still', 'such', 'take',
            'tell', 'than', 'that', 'their', 'them', 'then', 'there', 'these', 'they', 'thing',
            'think', 'this', 'those', 'three', 'through', 'time', 'turn', 'under', 'upon', 'very',
            'want', 'water', 'where', 'which', 'while', 'with', 'word', 'work', 'world', 'would',
            'write', 'year', 'your', 'back', 'call', 'came', 'can', 'come', 'day', 'did',
            'down', 'each', 'find', 'get', 'give', 'go', 'good', 'had', 'has', 'have',
            'her', 'here', 'him', 'his', 'how', 'just', 'know', 'let', 'like', 'look',
            'man', 'may', 'men', 'new', 'now', 'old', 'one', 'out', 'own', 'said',
            'say', 'see', 'she', 'some', 'than', 'the', 'them', 'then', 'two', 'up',
            'use', 'way', 'we', 'well', 'went', 'were', 'what', 'when', 'who', 'will'
        ];

        function createShapes() {
            const shapesContainer = document.getElementById('shapes');
            for (let i = 0; i < 8; i++) {
                const shape = document.createElement('div');
                shape.className = Math.random() > 0.5 ? 'shape circle' : 'shape square';
                shape.style.width = shape.style.height = (30 + Math.random() * 50) + 'px';
                shape.style.left = Math.random() * 100 + '%';
                shape.style.top = Math.random() * 100 + '%';
                shapesContainer.appendChild(shape);
            }
        }

        const loadingTexts = [
            'Loading experiment!',
            'Experiment designed by EJ and Aaron!',
            'Experiment game designed by EJ!'
        ];
        let loadingIndex = 0;

        function updateLoadingText() {
            const loadingTextEl = document.getElementById('loadingText');
            const loadingBar = document.getElementById('loadingBar');
            const progress = ((loadingIndex + 1) / loadingTexts.length) * 100;

            loadingBar.style.width = progress + '%';
            loadingTextEl.style.opacity = '0';
            loadingTextEl.style.transform = 'translateY(20px)';

            setTimeout(() => {
                loadingTextEl.textContent = loadingTexts[loadingIndex];
                loadingTextEl.style.animation = 'none';
                setTimeout(() => {
                    loadingTextEl.style.animation = 'slideUp 0.5s ease forwards';
                }, 10);
                playSound(440 + loadingIndex * 110, 0.1);
                loadingIndex++;

                if (loadingIndex < loadingTexts.length) {
                    setTimeout(updateLoadingText, 2000);
                } else {
                    setTimeout(() => {
                        const loadingScreen = document.getElementById('loadingScreen');
                        loadingScreen.classList.add('fade-out');
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                            const mainScreen = document.getElementById('mainScreen');
                            mainScreen.style.display = 'block';
                            setTimeout(() => mainScreen.classList.add('show'), 10);
                            playSound(660, 0.2);
                        }, 500);
                    }, 2000);
                }
            }, 300);
        }

        document.getElementById('toggleSwitch').addEventListener('click', function() {
            this.classList.toggle('active');
            researchMode = this.classList.contains('active');
            document.getElementById('trialCounter').style.display = researchMode ? 'block' : 'none';
            playSound(researchMode ? 880 : 440, 0.1);
        });

        function startGame(mode) {
            currentMode = mode;
            shownWords = [];
            currentWordIndex = 0;

            const shuffled = [...wordPool].sort(() => Math.random() - 0.5);
            shownWords = shuffled.slice(0, 15);

            const mainScreen = document.getElementById('mainScreen');
            mainScreen.classList.remove('show');

            setTimeout(() => {
                mainScreen.style.display = 'none';
                const gameScreen = document.getElementById('gameScreen');
                gameScreen.style.display = 'block';
                setTimeout(() => gameScreen.classList.add('show'), 10);
                playSound(550, 0.15);
                showNextWord();
            }, 600);
        }

        function showNextWord() {
            if (currentWordIndex >= shownWords.length) {
                playSound(660, 0.3);
                startRecall();
                return;
            }

            const word = shownWords[currentWordIndex];
            const wordDisplay = document.getElementById('wordDisplay');
            const wordCounter = document.getElementById('wordCounter');
            const progressFill = document.getElementById('progressFill');

            wordCounter.textContent = `Word ${currentWordIndex + 1} of 15`;
            progressFill.style.width = ((currentWordIndex + 1) / 15 * 100) + '%';

            wordDisplay.style.animation = 'none';
            wordDisplay.style.transform = 'scale(0.8) rotate(-10deg)';
            wordDisplay.style.opacity = '0';

            setTimeout(() => {
                wordDisplay.style.animation = 'popIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                wordDisplay.style.transform = '';
                wordDisplay.style.opacity = '1';
            }, 50);

            if (currentMode === 'experimental') {
                wordDisplay.innerHTML = generateCaptcha(word);
            } else {
                wordDisplay.innerHTML = word.toUpperCase();
            }

            playSound(330 + Math.random() * 220, 0.08);

            currentWordIndex++;
            setTimeout(showNextWord, 4000);
        }

        function generateCaptcha(word) {
            const letters = word.toUpperCase().split('');
            let html = '<div class="captcha-text" style="position: relative; display: inline-block;">';

            letters.forEach((letter, index) => {
                const rotation = (Math.random() - 0.5) * 45;
                const yOffset = (Math.random() - 0.5) * 25;
                const xOffset = (Math.random() - 0.5) * 12;
                const scale = 0.75 + Math.random() * 0.55;
                const skewX = (Math.random() - 0.5) * 35;
                const skewY = (Math.random() - 0.5) * 25;
                const blur = Math.random() * 1.8;
                const opacity = 0.5 + Math.random() * 0.4;

                const shadows = [];
                for (let i = 0; i < 5; i++) {
                    const shadowX = (Math.random() - 0.5) * 6;
                    const shadowY = (Math.random() - 0.5) * 6;
                    const shadowBlur = Math.random() * 3;
                    const shadowOpacity = 0.15 + Math.random() * 0.25;
                    shadows.push(`${shadowX}px ${shadowY}px ${shadowBlur}px rgba(0,0,0,${shadowOpacity})`);
                }

                const letterDecoration = Math.random();
                let extraStyle = '';
                if (letterDecoration < 0.3) {
                    extraStyle = 'text-decoration: line-through;';
                } else if (letterDecoration < 0.5) {
                    extraStyle = 'text-decoration: underline overline;';
                }

                html += `<span class="captcha-letter" style="
                    transform: rotate(${rotation}deg) translateY(${yOffset}px) translateX(${xOffset}px) scale(${scale}) skewX(${skewX}deg) skewY(${skewY}deg);
                    opacity: ${opacity};
                    filter: blur(${blur}px) contrast(${100 + Math.random() * 50}%);
                    text-shadow: ${shadows.join(', ')};
                    display: inline-block;
                    font-weight: ${Math.random() > 0.5 ? 'bold' : '900'};
                    ${extraStyle}
                    letter-spacing: ${(Math.random() - 0.5) * 3}px;
                ">${letter}</span>`;
            });

            const numLines = 6 + Math.floor(Math.random() * 5);
            for (let i = 0; i < numLines; i++) {
                const top = 5 + Math.random() * 90;
                const rotation = (Math.random() - 0.5) * 40;
                const opacity = 0.3 + Math.random() * 0.35;
                const thickness = 1 + Math.random() * 3;
                const isWavy = Math.random() > 0.5;

                if (isWavy) {
                    html += `<div style="
                        position: absolute;
                        top: ${top}%;
                        left: -10%;
                        width: 120%;
                        height: ${thickness}px;
                        background: repeating-linear-gradient(
                            90deg,
                            rgba(0,0,0,${opacity}) 0px,
                            rgba(0,0,0,${opacity}) 5px,
                            transparent 5px,
                            transparent 10px
                        );
                        transform: rotate(${rotation}deg);
                    "></div>`;
                } else {
                    html += `<div class="captcha-line" style="
                        top: ${top}%;
                        transform: rotate(${rotation}deg);
                        opacity: ${opacity};
                        height: ${thickness}px;
                        background: ${Math.random() > 0.5 ? 'rgba(0,0,0,0.4)' : 'rgba(100,100,100,0.35)'};
                    "></div>`;
                }
            }

            const numDots = 15 + Math.floor(Math.random() * 20);
            for (let i = 0; i < numDots; i++) {
                const left = Math.random() * 100;
                const top = Math.random() * 100;
                const size = 1 + Math.random() * 5;
                const opacity = 0.2 + Math.random() * 0.3;
                const isSquare = Math.random() > 0.7;
                html += `<div style="
                    position: absolute;
                    left: ${left}%;
                    top: ${top}%;
                    width: ${size}px;
                    height: ${size}px;
                    background: rgba(0,0,0,${opacity});
                    border-radius: ${isSquare ? '0' : '50%'};
                    transform: rotate(${Math.random() * 360}deg);
                "></div>`;
            }

            const numBlocks = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numBlocks; i++) {
                const left = Math.random() * 90;
                const top = Math.random() * 90;
                const width = 5 + Math.random() * 15;
                const height = 5 + Math.random() * 15;
                const opacity = 0.05 + Math.random() * 0.15;
                html += `<div style="
                    position: absolute;
                    left: ${left}%;
                    top: ${top}%;
                    width: ${width}px;
                    height: ${height}px;
                    background: rgba(0,0,0,${opacity});
                    transform: rotate(${Math.random() * 45}deg);
                "></div>`;
            }

            html += '<div class="captcha-wave"></div>';

            html += '<div class="captcha-noise"></div>';

            html += '<div class="captcha-overlay"></div>';

            html += `<div style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,0.05) 2px,
                    rgba(0,0,0,0.05) 4px
                );
                pointer-events: none;
            "></div>`;

            html += '</div>';

            return html;
        }

        function startRecall() {
            const gameScreen = document.getElementById('gameScreen');
            gameScreen.classList.remove('show');

            setTimeout(() => {
                gameScreen.style.display = 'none';
                const recallScreen = document.getElementById('recallScreen');
                recallScreen.style.display = 'block';
                setTimeout(() => recallScreen.classList.add('show'), 10);

                const recallGrid = document.getElementById('recallGrid');
                recallGrid.innerHTML = '';

                for (let i = 0; i < 15; i++) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'recall-input-wrapper';
                    wrapper.innerHTML = `
                        <span class="recall-label">Word ${i + 1}</span>
                        <input type="text" class="recall-input" id="recall${i}" maxlength="10">
                    `;
                    recallGrid.appendChild(wrapper);
                }

                document.getElementById('recall0').focus();
            }, 500);
        }

        function submitRecall() {
            const userAnswers = [];
            for (let i = 0; i < 15; i++) {
                const input = document.getElementById(`recall${i}`);
                userAnswers.push(input.value.toLowerCase().trim());
            }

            playSound(770, 0.2);
            calculateResults(userAnswers);
        }

        function calculateResults(userAnswers) {
            let correctWords = 0;
            let totalLetters = 0;
            let correctLetters = 0;
            const details = [];

            for (let i = 0; i < 15; i++) {
                const correct = shownWords[i];
                const user = userAnswers[i];
                const isCorrect = correct === user;

                if (isCorrect) correctWords++;

                totalLetters += correct.length;
                for (let j = 0; j < correct.length; j++) {
                    if (correct[j] === (user[j] || '')) {
                        correctLetters++;
                    }
                }

                details.push({
                    position: i + 1,
                    correct: correct,
                    user: user,
                    isCorrect: isCorrect
                });
            }

            const wordAccuracy = (correctWords / 15 * 100).toFixed(1);
            const letterAccuracy = (correctLetters / totalLetters * 100).toFixed(1);

            const result = {
                mode: currentMode,
                wordAccuracy: parseFloat(wordAccuracy),
                letterAccuracy: parseFloat(letterAccuracy),
                details: details,
                timestamp: new Date().toISOString()
            };

            gameHistory[currentMode].push(result);

            if (researchMode) {
                updateTrialCounter();
                if (gameHistory[currentMode].length === 10) {
                    playSound(880, 0.5);
                    alert(`Completed 10 ${currentMode} trials! Data is ready for export.`);
                }
            }

            displayResults(result);
        }

        function updateTrialCounter() {
            document.getElementById('controlCount').textContent = gameHistory.control.length;
            document.getElementById('expCount').textContent = gameHistory.experimental.length;
        }

        function displayResults(result) {
            const recallScreen = document.getElementById('recallScreen');
            recallScreen.classList.remove('show');

            setTimeout(() => {
                recallScreen.style.display = 'none';
                const resultsScreen = document.getElementById('resultsScreen');
                resultsScreen.style.display = 'block';
                setTimeout(() => resultsScreen.classList.add('show'), 10);

                document.getElementById('accuracyDisplay').textContent = result.wordAccuracy + '%';
                document.getElementById('modeDisplay').textContent = result.mode.charAt(0).toUpperCase() + result.mode.slice(1);

                drawScatterPlot(result);
                analyzeWithAI(result);

                const table = document.getElementById('resultsTable');
                table.innerHTML = `
                    <tr>
                        <th>Position</th>
                        <th>Correct Word</th>
                        <th>Your Answer</th>
                        <th>Status</th>
                    </tr>
                `;

                result.details.forEach(detail => {
                    const row = table.insertRow();
                    row.innerHTML = `
                        <td>${detail.position}</td>
                        <td>${detail.correct}</td>
                        <td>${detail.user || '(blank)'}</td>
                        <td class="${detail.isCorrect ? 'correct' : 'incorrect'}">
                            ${detail.isCorrect ? 'âœ“ Correct' : 'âœ— Incorrect'}
                        </td>
                    `;
                });
            }, 500);
        }

        function drawScatterPlot(result) {
            const canvas = document.getElementById('scatterPlot');
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';

            ctx.fillText('Word Position vs Accuracy', canvas.width / 2 - 100, 30);

            const padding = 60;
            const plotWidth = canvas.width - padding * 2;
            const plotHeight = canvas.height - padding * 2;
            const originX = padding;
            const originY = canvas.height - padding;

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + plotWidth, originY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX, originY - plotHeight);
            ctx.stroke();

            ctx.font = '12px Arial';
            ctx.fillText('Word Position', canvas.width / 2 - 40, canvas.height - 10);
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Correct (1) / Incorrect (0)', 0, 0);
            ctx.restore();

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 15; i++) {
                const x = originX + (plotWidth / 15) * i;
                ctx.beginPath();
                ctx.moveTo(x, originY);
                ctx.lineTo(x, originY - plotHeight);
                ctx.stroke();

                if (i % 3 === 0) {
                    ctx.fillStyle = '#666';
                    ctx.fillText(i.toString(), x - 5, originY + 20);
                }
            }

            for (let i = 0; i <= 1; i++) {
                const y = originY - (plotHeight * i);
                ctx.beginPath();
                ctx.moveTo(originX, y);
                ctx.lineTo(originX + plotWidth, y);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.fillText(i.toString(), originX - 30, y + 5);
            }

            result.details.forEach((detail, index) => {
                const x = originX + (plotWidth / 15) * (index + 1);
                const y = originY - (plotHeight * (detail.isCorrect ? 1 : 0));

                const jitterX = (Math.random() - 0.5) * 10;
                const jitterY = (Math.random() - 0.5) * 20;

                ctx.fillStyle = detail.isCorrect ? '#2d7a2d' : '#c53030';
                ctx.beginPath();
                ctx.arc(x + jitterX, y + jitterY, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            const correctByPosition = result.details.map((d, i) => ({ x: i + 1, y: d.isCorrect ? 1 : 0 }));
            drawTrendLine(ctx, correctByPosition, originX, originY, plotWidth, plotHeight);
        }

        function drawTrendLine(ctx, points, originX, originY, plotWidth, plotHeight) {

            const windowSize = 3;
            const smoothed = [];

            for (let i = 0; i < points.length; i++) {
                let sum = 0;
                let count = 0;
                for (let j = Math.max(0, i - windowSize + 1); j <= Math.min(points.length - 1, i + windowSize - 1); j++) {
                    sum += points[j].y;
                    count++;
                }
                smoothed.push({ x: points[i].x, y: sum / count });
            }

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();

            smoothed.forEach((point, index) => {
                const x = originX + (plotWidth / 15) * point.x;
                const y = originY - (plotHeight * point.y);

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();
            ctx.setLineDash([]);
        }

        async function analyzeWithAI(result) {
            const analysisDiv = document.getElementById('analysisText');

            try {
                let prompt = '';

                if (researchMode && gameHistory[result.mode].length >= 10) {

                    const trials = gameHistory[result.mode];
                    const avgAccuracy = trials.reduce((sum, t) => sum + t.wordAccuracy, 0) / trials.length;
                    const accuracies = trials.map(t => t.wordAccuracy);
                    const stdDev = Math.sqrt(accuracies.reduce((sum, acc) => sum + Math.pow(acc - avgAccuracy, 2), 0) / trials.length);

                    prompt = `Analyze these memory experiment results for ${result.mode} mode (10 trials):

Average Accuracy: ${avgAccuracy.toFixed(1)}%
Standard Deviation: ${stdDev.toFixed(1)}%
Range: ${Math.min(...accuracies).toFixed(1)}% - ${Math.max(...accuracies).toFixed(1)}%
Mode: ${result.mode === 'control' ? 'Standard Arial text' : 'CAPTCHA-distorted text'}

Individual trial accuracies: ${accuracies.map(a => a.toFixed(1) + '%').join(', ')}

Please provide:
1. Statistical interpretation of these results
2. Analysis of consistency (standard deviation)
3. Whether visual distortion (if experimental) appears to affect memory retention
4. Notable patterns or trends across trials
5. Recommendations for the researchers

Keep it concise and scientific.`;
                } else {

                    const positionAccuracy = result.details.map((d, i) => ({ position: i + 1, correct: d.isCorrect }));
                    const earlyAccuracy = positionAccuracy.slice(0, 5).filter(p => p.correct).length / 5;
                    const middleAccuracy = positionAccuracy.slice(5, 10).filter(p => p.correct).length / 5;
                    const lateAccuracy = positionAccuracy.slice(10, 15).filter(p => p.correct).length / 5;

                    prompt = `Analyze this single memory experiment result:

Mode: ${result.mode === 'control' ? 'Standard Arial text' : 'CAPTCHA-distorted text'}
Overall Word Accuracy: ${result.wordAccuracy}%
Letter-level Accuracy: ${result.letterAccuracy}%

Position-based accuracy:
- Early words (1-5): ${(earlyAccuracy * 100).toFixed(1)}%
- Middle words (6-10): ${(middleAccuracy * 100).toFixed(1)}%
- Late words (11-15): ${(lateAccuracy * 100).toFixed(1)}%

Please provide:
1. Analysis of the serial position effect (primacy/recency)
2. Impact of visual distortion on memory (if experimental mode)
3. Comparison of word vs letter accuracy
4. Notable patterns in the data
5. Brief recommendations for improving memory retention

Keep it concise and scientific.`;
                }

                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=AIzaSyD0EHsqT59RHTbtHKplLKb6Z4iSftHfUYw', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }]
                    })
                });

                const data = await response.json();

                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    const analysisText = data.candidates[0].content.parts[0].text;
                    analysisDiv.innerHTML = `
                        <h4 style="margin-top: 0; color: #222;">ðŸ¤– AI Analysis</h4>
                        <div style="white-space: pre-wrap; line-height: 1.6; color: #333;">${analysisText}</div>
                    `;
                } else {
                    analysisDiv.innerHTML = '<p style="color: #c53030;">Unable to generate AI analysis. Please try again.</p>';
                }
            } catch (error) {
                console.error('AI Analysis error:', error);
                analysisDiv.innerHTML = '<p style="color: #c53030;">Error connecting to AI analysis service.</p>';
            }
        }

        function exportResults() {
            let exportData = {};

            if (researchMode && (gameHistory.control.length === 10 || gameHistory.experimental.length === 10)) {

                exportData = {
                    researchMode: true,
                    timestamp: new Date().toISOString(),
                    control: {
                        trials: gameHistory.control,
                        summary: calculateSummary(gameHistory.control)
                    },
                    experimental: {
                        trials: gameHistory.experimental,
                        summary: calculateSummary(gameHistory.experimental)
                    }
                };
            } else {

                const currentResult = gameHistory[currentMode][gameHistory[currentMode].length - 1];
                exportData = {
                    researchMode: false,
                    timestamp: new Date().toISOString(),
                    result: currentResult,
                    summary: calculateSummary([currentResult])
                };
            }

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `experiment-results-${Date.now()}.json`;
            a.click();

            playSound(660, 0.2);
        }

        function calculateSummary(trials) {
            if (trials.length === 0) return null;

            const accuracies = trials.map(t => t.wordAccuracy);
            const letterAccuracies = trials.map(t => t.letterAccuracy);

            const avgWordAccuracy = accuracies.reduce((a, b) => a + b, 0) / accuracies.length;
            const avgLetterAccuracy = letterAccuracies.reduce((a, b) => a + b, 0) / letterAccuracies.length;

            const wordStdDev = Math.sqrt(
                accuracies.reduce((sum, acc) => sum + Math.pow(acc - avgWordAccuracy, 2), 0) / accuracies.length
            );

            return {
                count: trials.length,
                avgWordAccuracy: avgWordAccuracy.toFixed(2),
                avgLetterAccuracy: avgLetterAccuracy.toFixed(2),
                stdDev: wordStdDev.toFixed(2),
                minAccuracy: Math.min(...accuracies).toFixed(2),
                maxAccuracy: Math.max(...accuracies).toFixed(2)
            };
        }

        function returnToMain() {
            const resultsScreen = document.getElementById('resultsScreen');
            resultsScreen.classList.remove('show');

            setTimeout(() => {
                resultsScreen.style.display = 'none';
                const mainScreen = document.getElementById('mainScreen');
                mainScreen.style.display = 'block';
                setTimeout(() => mainScreen.classList.add('show'), 10);
                playSound(440, 0.15);
            }, 500);
        }

        window.onload = function() {
            createShapes();
            setTimeout(updateLoadingText, 500);
        };
    </script>
</body>
</html>
